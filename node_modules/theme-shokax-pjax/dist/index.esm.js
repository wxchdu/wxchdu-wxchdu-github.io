function forEachEls (els, fn, context) {
    if (els instanceof HTMLCollection ||
        els instanceof NodeList ||
        els instanceof Array) {
        return Array.prototype.forEach.call(els, fn, context);
    }
    else {
        // assume simple DOM element
        return fn.call(context, els, 0, [els]);
    }
}

const eventForEach = (events, fn) => {
    events = typeof events === "string" ? events.split(" ") : events;
    events.forEach(fn);
};
function on(els, events, listener, useCapture) {
    eventForEach(events, (e) => {
        forEachEls(els, (el) => {
            el.addEventListener(e, listener, useCapture);
        });
    });
}
// do not support IE !!!
function trigger(els, events, opts = {}) {
    eventForEach(events, (e) => {
        const event = new CustomEvent(e, {
            bubbles: true,
            cancelable: true,
            ...opts,
        });
        forEachEls(els, (el) => {
            el.dispatchEvent(event);
        });
    });
}

function evalScript (el) {
    const code = el.text || el.textContent || el.innerHTML || "";
    const src = el.src || "";
    const parent = el.parentNode || document.querySelector("head") || document.documentElement;
    const script = document.createElement("script");
    if (code.match("document.write")) {
        return false;
    }
    script.type = "text/javascript";
    script.id = el.id;
    if (src !== "") {
        script.src = src;
        script.async = false; // force synchronous loading of peripheral JS
    }
    if (code !== "") {
        script.appendChild(document.createTextNode(code));
    }
    // execute
    parent.appendChild(script);
    // avoid pollution only in head or body tags
    if ((parent instanceof HTMLHeadElement || parent instanceof HTMLBodyElement) &&
        parent.contains(script)) {
        parent.removeChild(script);
    }
    return true;
}

// Finds and executes scripts (used for newly added elements)
// Needed since innerHTML does not run scripts
function executeScripts (el) {
    if (el.tagName.toLowerCase() === "script") {
        evalScript(el);
    }
    forEachEls(el.querySelectorAll("script"), (script) => {
        const scriptElement = script;
        if (!scriptElement.type ||
            scriptElement.type.toLowerCase() === "text/javascript") {
            if (scriptElement.parentNode) {
                scriptElement.parentNode.removeChild(scriptElement);
            }
            evalScript(scriptElement);
        }
    });
}

function forEachSelectors (selectors, cb, context, DOMcontext = document) {
    selectors.forEach((selector) => {
        forEachEls(DOMcontext.querySelectorAll(selector), cb, context);
    });
}

var newUid = (() => {
    let counter = 0;
    return () => `pjax${new Date().getTime()}_${counter++}`;
})();

function outerHTML(oldEl, newEl) {
    oldEl.outerHTML = newEl.outerHTML;
    this.onSwitch();
}
function innerHTML(oldEl, newEl) {
    oldEl.innerHTML = newEl.innerHTML;
    if (newEl.className === "") {
        oldEl.removeAttribute("class");
    }
    else {
        oldEl.className = newEl.className;
    }
    this.onSwitch();
}
function switchElementsAlt(oldEl, newEl) {
    oldEl.innerHTML = newEl.innerHTML;
    // Copy attributes from the new element to the old one
    if (newEl.hasAttributes()) {
        const attrs = newEl.attributes;
        for (let i = 0; i < attrs.length; i++) {
            oldEl.attributes.setNamedItem(attrs[i].cloneNode());
        }
    }
    this.onSwitch();
}

function pjax({ elements = "a[href]", selectors = ["title", ".js-Pjax"], switches = {}, switchesOptions = {}, history = true, scrollTo = 0, scrollRestoration = true, cacheBust = true, timeout = 0, currentUrlFullReload = false, } = {}) {
    const options = {
        elements,
        selectors,
        switches,
        switchesOptions,
        history,
        scrollTo,
        scrollRestoration,
        cacheBust,
        timeout,
        currentUrlFullReload,
    };
    // We can’t replace body.outerHTML or head.outerHTML.
    // It creates a bug where a new body or head are created in the DOM.
    // If you set head.outerHTML, a new body tag is appended, so the DOM has 2 body nodes, and vice versa
    if (!options.switches.head) {
        options.switches.head = switchElementsAlt;
    }
    if (!options.switches.body) {
        options.switches.body = switchElementsAlt;
    }
    return options;
}

const attrState = "data-pjax-state";
function linkAction(el, event) {
    if (event.defaultPrevented || event.returnValue === false) {
        return;
    }
    // Since loadUrl modifies options, and we may add our own modifications below,
    // clone it so the changes don't persist
    const options = { ...this.options };
    const attrValue = checkIfShouldAbort(el, event);
    if (attrValue) {
        el.setAttribute(attrState, attrValue);
        return;
    }
    event.preventDefault();
    // don’t do "nothing" if the user tries to reload the page by clicking the same link twice
    if (this.options.currentUrlFullReload &&
        el.href === window.location.href.split("#")[0]) {
        el.setAttribute(attrState, "reload");
        this.reload();
        return;
    }
    el.setAttribute(attrState, "load");
    options.triggerElement = el;
    this.loadUrl(el.href, options);
}
function checkIfShouldAbort(el, event) {
    // Don’t break browser special behavior on links (like opening in a new window)
    if (event.which > 1 ||
        event.metaKey ||
        event.ctrlKey ||
        event.shiftKey ||
        event.altKey) {
        return "modifier";
    }
    // we do test on href now to prevent unexpected behavior if for some reason
    // the user has an href that can be dynamically updated
    // Ignore external links.
    if (el.protocol !== window.location.protocol ||
        el.host !== window.location.host) {
        return "external";
    }
    // Ignore anchors on the same page (keep native behavior)
    if (el.hash &&
        el.href.replace(el.hash, "") ===
            window.location.href.replace(location.hash, "")) {
        return "anchor";
    }
    // Ignore empty anchor "foo.html#"
    if (el.href === window.location.href.split("#")[0] + "#") {
        return "anchor-empty";
    }
    return null;
}
function attachLink (el) {
    el.setAttribute(attrState, "");
    on(el, "click", (event) => linkAction.call(this, el, event));
    on(el, "keyup", (event) => {
        const keyboardEvent = event;
        if (keyboardEvent.keyCode === 13) {
            linkAction.call(this, el, keyboardEvent);
        }
    });
}

function handleResponse (responseText, request, href, options) {
    options = { ...(options || this.options) };
    options.request = request;
    // Fail if unable to load HTML via AJAX
    if (responseText === false) {
        trigger(document, "pjax:complete pjax:error", options);
        return;
    }
    // push scroll position to history
    const currentState = window.history.state || {};
    window.history.replaceState({
        url: currentState.url || window.location.href,
        title: currentState.title || document.title,
        uid: currentState.uid || newUid(),
        scrollPos: [
            document.documentElement.scrollLeft || document.body.scrollLeft,
            document.documentElement.scrollTop || document.body.scrollTop,
        ],
    }, document.title, window.location.href);
    // Check for redirects
    const oldHref = href;
    if (request.responseURL) {
        if (href !== request.responseURL) {
            href = request.responseURL;
        }
    }
    else if (request.getResponseHeader("X-PJAX-URL")) {
        href = request.getResponseHeader("X-PJAX-URL");
    }
    else if (request.getResponseHeader("X-XHR-Redirected-To")) {
        href = request.getResponseHeader("X-XHR-Redirected-To");
    }
    // Add back the hash if it was removed
    const a = document.createElement("a");
    a.href = oldHref;
    const oldHash = a.hash;
    a.href = href;
    if (oldHash && !a.hash) {
        a.hash = oldHash;
        href = a.href;
    }
    this.state.href = href;
    this.state.options = options;
    try {
        this.loadContent(responseText, options);
    }
    catch (e) {
        trigger(document, "pjax:error", options);
        console.error("Pjax switch fail: ", e);
        return this.latestChance(href);
    }
}

function parseElement (el) {
    switch (el.tagName.toLowerCase()) {
        case "a":
            // only attach link if el does not already have link attached
            if (!el.hasAttribute("data-pjax-state")) {
                this.attachLink(el);
            }
            break;
        // form does not exist in shokax
        default:
            throw new Error("theme-shokax-pjax can only be applied on <a>");
    }
}

function updateQueryString (uri, key, value) {
    const re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
    const separator = uri.indexOf("?") !== -1 ? "&" : "?";
    if (uri.match(re)) {
        return uri.replace(re, "$1" + key + "=" + value + "$2");
    }
    else {
        return uri + separator + key + "=" + value;
    }
}

function sendRequest (location, options = {}, callback) {
    const requestOptions = options.requestOptions || {};
    const requestMethod = (requestOptions.requestMethod || "GET").toUpperCase();
    const requestParams = requestOptions.requestParams || null;
    let requestPayload = null;
    const request = new XMLHttpRequest();
    const timeout = options.timeout;
    request.onreadystatechange = () => {
        if (request.readyState === 4) {
            if (request.status === 200) {
                callback(request.responseText, request, location, options);
            }
            else if (request.status !== 0) {
                callback(null, request, location, options);
            }
        }
    };
    request.onerror = (e) => {
        console.error(e);
        callback(null, request, location, options);
    };
    request.ontimeout = () => {
        callback(null, request, location, options);
    };
    // Prepare the request payload for forms, if available
    if (requestParams && requestParams.length) {
        // Build query string
        let queryString = requestParams
            .map((param) => param.name + "=" + param.value)
            .join("&");
        switch (requestMethod) {
            case "GET":
                // Reset query string to avoid an issue with repeat submissions where checkboxes that were
                // previously checked are incorrectly preserved
                location = location.split("?")[0];
                // Append new query string
                location += "?" + queryString;
                break;
            case "POST":
                // Send query string as request payload
                requestPayload = queryString;
                break;
        }
    }
    // Add a timestamp as part of the query string if cache busting is enabled
    if (options.cacheBust) {
        location = updateQueryString(location, "t", Date.now());
    }
    request.open(requestMethod, location, true);
    request.timeout = timeout;
    request.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    request.setRequestHeader("X-PJAX", "true");
    request.setRequestHeader("X-PJAX-Selectors", JSON.stringify(options.selectors));
    request.send(requestPayload);
    return request;
}

function switchesSelectors (switches, switchesOptions, selectors, fromEl, toEl, options) {
    const switchesQueue = [];
    selectors.forEach((selector) => {
        const newEls = fromEl.querySelectorAll(selector);
        const oldEls = toEl.querySelectorAll(selector);
        if (newEls.length !== oldEls.length) {
            throw new Error(`DOM doesn't look the same on new loaded page: '${selector}' - new ${newEls.length}, old ${oldEls.length}`);
        }
        forEachEls(newEls, (newEl, i) => {
            const oldEl = oldEls[i];
            const callback = switches[selector]
                ? switches[selector].bind(this, oldEl, newEl, options, switchesOptions[selector])
                : outerHTML.bind(this, oldEl, newEl, options);
            switchesQueue.push(callback);
        }, this);
    }, this);
    this.state.numPendingSwitches = switchesQueue.length;
    switchesQueue.forEach((queuedSwitch) => {
        queuedSwitch();
    });
}

function contains (doc, selectors, el) {
    for (const selector of selectors) {
        const selectedEls = doc.querySelectorAll(selector);
        for (let j = 0; j < selectedEls.length; j++) {
            if (selectedEls[j].contains(el)) {
                return true;
            }
        }
    }
    return false;
}

class Pjax {
    constructor(options) {
        this.state = {
            numPendingSwitches: 0,
            href: null,
            options: null,
        };
        this.options = pjax(options);
        if (this.options.scrollRestoration && "scrollRestoration" in history) {
            history.scrollRestoration = "manual";
        }
        this.maxUid = this.lastUid = newUid();
        this.parseDOM(document);
        on(window, "popstate", (e) => {
            const st = e;
            if (st.state) {
                const opt = { ...this.options };
                opt.url = st.state.url;
                opt.title = st.state.title;
                // Since state already exists, prevent it from being pushed again
                opt.history = false;
                opt.scrollPos = st.state.scrollPos;
                if (st.state.uid < this.lastUid) {
                    opt.backward = true;
                }
                else {
                    opt.forward = true;
                }
                this.lastUid = st.state.uid;
                // @todo implement history cache here, based on uid
                this.loadUrl(st.state.url, opt);
            }
        });
    }
    getElements(el) {
        return el.querySelectorAll(this.options.elements);
    }
    parseDOM(el) {
        forEachEls(this.getElements(el), parseElement, this);
    }
    refresh(el) {
        this.parseDOM(el || document);
    }
    reload() {
        window.location.reload();
    }
    forEachSelectors(cb, context, DOMcontext) {
        return forEachSelectors.bind(this)(this.options.selectors, cb, context, DOMcontext);
    }
    switchSelectors(selectors, fromEl, toEl, options) {
        return switchesSelectors.bind(this)(this.options.switches, this.options.switchesOptions, selectors, fromEl, toEl, options);
    }
    latestChance(href) {
        window.location = href;
    }
    onSwitch() {
        trigger(window, "resize scroll");
        this.state.numPendingSwitches--;
        // debounce calls, so we only run this once after all switches are finished.
        if (this.state.numPendingSwitches === 0) {
            this.afterAllSwitches();
        }
    }
    loadContent(html, options) {
        if (typeof html !== "string") {
            trigger(document, "pjax:complete pjax:error", options);
            return;
        }
        const tmpEl = document.implementation.createHTMLDocument("pjax");
        // parse HTML attributes to copy them
        // since we are forced to use documentElement.innerHTML (outerHTML can't be used for <html>)
        const htmlRegex = /<html[^>]+>/gi;
        const htmlAttribsRegex = /\s?[a-z:]+(?:=['"][^'">]+['"])*/gi;
        let matches = html.match(htmlRegex);
        if (matches && matches.length) {
            matches = matches[0].match(htmlAttribsRegex);
            if (matches.length) {
                matches.shift();
                matches.forEach((htmlAttrib) => {
                    const attr = htmlAttrib.trim().split("=");
                    if (attr.length === 1) {
                        tmpEl.documentElement.setAttribute(attr[0], "true");
                    }
                    else {
                        tmpEl.documentElement.setAttribute(attr[0], attr[1].slice(1, -1));
                    }
                });
            }
        }
        tmpEl.documentElement.innerHTML = html;
        if (document.activeElement &&
            contains(document, this.options.selectors, document.activeElement)) {
            try {
                document.activeElement.blur();
            }
            catch (e) { } // eslint-disable-line no-empty
        }
        this.switchSelectors(this.options.selectors, tmpEl, document, options);
    }
    loadUrl(href, options) {
        options =
            typeof options === "object"
                ? { ...this.options, ...options }
                : { ...this.options };
        // Abort any previous request
        this.abortRequest(this.request);
        trigger(document, "pjax:send", options);
        // Do the request
        this.request = this.doRequest(href, options, this.handleResponse.bind(this));
    }
    afterAllSwitches() {
        var _a, _b, _c;
        // execute scripts when DOM have been completely updated
        this.options.selectors.forEach((selector) => {
            forEachEls(document.querySelectorAll(selector), (el) => {
                executeScripts(el);
            });
        });
        const state = this.state;
        if ((_a = state.options) === null || _a === void 0 ? void 0 : _a.history) {
            if (!window.history.state) {
                this.lastUid = this.maxUid = newUid();
                window.history.replaceState({
                    url: window.location.href,
                    title: document.title,
                    uid: this.maxUid,
                    scrollPos: [0, 0],
                }, document.title);
            }
            // Update browser history
            this.lastUid = this.maxUid = newUid();
            window.history.pushState({
                url: state.href,
                title: state.options.title,
                uid: this.maxUid,
                scrollPos: [0, 0],
            }, state.options.title, state.href);
        }
        this.forEachSelectors((el) => {
            this.parseDOM(el);
        }, this);
        // Fire Events
        trigger(document, "pjax:complete pjax:success", state.options);
        if ((_b = state.options) === null || _b === void 0 ? void 0 : _b.history) {
            // First parse url and check for hash to override scroll
            const a = document.createElement("a");
            a.href = this.state.href;
            if (a.hash) {
                let name = a.hash.slice(1);
                name = decodeURIComponent(name);
                let curTop = 0;
                let target = document.getElementById(name) || document.getElementsByName(name)[0];
                if (target) {
                    // http://stackoverflow.com/questions/8111094/cross-browser-javascript-function-to-find-actual-position-of-an-element-in-page
                    if (target.offsetParent) {
                        do {
                            curTop += target.offsetTop;
                            target = target.offsetParent;
                        } while (target);
                    }
                }
                window.scrollTo(0, curTop);
            }
            else if (state.options.scrollTo !== false) {
                // Scroll page to top on new page load
                if (Array.isArray(state.options.scrollTo)) {
                    window.scrollTo(state.options.scrollTo[0], state.options.scrollTo[1]);
                }
                else {
                    window.scrollTo(0, state.options.scrollTo);
                }
            }
        }
        else if (((_c = state.options) === null || _c === void 0 ? void 0 : _c.scrollRestoration) && state.options.scrollPos) {
            window.scrollTo(state.options.scrollPos[0], state.options.scrollPos[1]);
        }
        this.state = {
            numPendingSwitches: 0,
            href: null,
            options: null,
        };
    }
    abortRequest(request) {
        if (request && request.readyState < 4) {
            request.onreadystatechange = () => { };
            request.abort();
        }
    }
}
Pjax.prototype.attachLink = attachLink;
Pjax.prototype.doRequest = sendRequest;
Pjax.prototype.handleResponse = handleResponse;
Pjax.switches = { innerHTML, outerHTML };

export { Pjax as default };
